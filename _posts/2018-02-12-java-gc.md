---
title: Java 垃圾回收
---

## Java垃圾回收

### 垃圾回收
垃圾回收发生在Java堆空间中，堆空间中有Java对象生成的对象，栈空间保存着指向堆空间中的对象的引用。在方法结束之后，栈空间被清空，该引用就不存在了，但是对象还留存在堆空间中。
在C语言中，分配给变量的内存需要手动取回收，而Java中，不需要手动操作这些内存空间，堆空间的对象在内存不够用的时候会被回收。这里涉及到几个部分的问题。第一，什么样的对象可以被回收。第二，怎么回收这些对象。第三，什么时候回收这些对象。

### 判断一个对象可以被回收
1. 计算引用数量
Java早期版本以及现在Python都是使用这种方法标记对象是否可以被回收的。
2. 从gc root遍历
现在Java整理标记可以被回收的对象的方法，是从根节点出发，遍历所有对象。遍历结束之后，未能达到的对象就是清理的对象。这种方法避免了循环引用的垃圾对象。
这里的根节点一般是指静态变量以及静态方法等等方法区内的变量。

### 垃圾回收算法
1. 标记-清除(mark-sweep)
最基础的算法，非常简单的实现。
标记：先标记出所有需要被护手的对象
清除：回收被标记的对象所占用的空间
算法实现很简单，它的弊端是容易产生内存碎片，在分配大对象的时候会造成无法分配而产生额外的垃圾回收动作。

2. 复制 (Copying)
为了解决 标记-清除 算法的缺陷，Copying算法将内存按照容量划分为两个相同大小的块，每次只使用其中之一。当此块内存空间使用完毕之后，将标记为存活的对象复制到另外一块内存空间中，然后将已经使用的空间全部清理掉。这样一来，就不容易出现内存碎片问题了。
算法的弊端是，内存可用的空间只有内存本身的一半，代价比较大，并且在存活的内存对象比较多的时候，复制的效率也会比较低。

3. 标记-整理(mark-compact)
标记-整理的方法解决了复制法的缺陷。它的标记法和标记-清除一致，在标记完所有留存的对象之后，并不直接清理可回收对象，而是将存活对象向一端移动，清理掉剩余的内存，这样一样能够避免内存碎片。

### Java分代回收法
Java分代回收法并不是一种单独的垃圾回收方法，实际上是针对不同的内存块，使用了不同的垃圾回收算法。这个是目前大部分JVM垃圾回收采用的算法。
核心思想是将内存分代，分别是：新生代(Young Generation)，老年代(Tenured Generation)，永生代(Permanet Generation)
* 新生代分为1个Eden区 和两个Survivor区(Survivor0,Survivor1)
  新对象申请会在Eden区，Eden区满无法申请新对象的话，会在Eden区进行垃圾回收，这里使用的是复制法，将Eden区存活的对象以及Survivor0中存活的对象复制到Survivor1中，然后将Eden和Survivor0区全部清空。下一次GC时，将Eden区和Survivor1中存活的对象复制到Survivor0,将Eden和Survivor1清空。
  Eden区 Survivor0 Survivor1 大小分为为 8:1:1
* 老年代很少参与内存回收，在对象经过N次新生代内存回收复制过程之后(Java默认15次)
  老年代内存回收通常使用标记-整理法
* 永生代存储class类，常量等等

### 何时进行垃圾回收
垃圾回收分为两类
* Young GC 或者 Minor GC，仅发生在新生代中。在Eden区满时，进行回收。
* Full GC，JVM中全部区进行垃圾回收。这种垃圾回收发生在很多情况下。
  由于Eden空间大于Survivor区，当Young GC过程中，一个Survivor区无法放下Eden和另外一个Survivor区的存活变量时，会进行Full GC，将部分对象转移到老生代中。
  永生代中的类和常量增长到空间不足时，也会进行GC，主要清理无用的类和废弃的变量。
在Java多线程中，有一个概念是GC会在所有线程进入一个SAFE POINT之后，再进行垃圾回收。这主要是为了避免某个对象，暂时没有引用，在后续某个线程被使用到，而GC错误的回收了这个对象会导致线程空指针的报错。
